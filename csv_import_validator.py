#!/usr/bin/env python3
"""
CSV Import Validation Checker for Cell Storage System

This program validates CSV files before import to identify potential issues
that would cause import failures. It replicates the validation logic from
the import_csv() function in routes.py.

Usage:
    python csv_import_validator.py <csv_file_path>

Author: Generated by Claude Code
"""

import sys
import os
import csv
import io
import re
from datetime import datetime
from typing import List, Tuple, Dict, Any
from dataclasses import dataclass
from pathlib import Path

# Add the app directory to Python path for imports
sys.path.insert(0, os.path.join(os.path.dirname(__file__), 'app'))

try:
    from app import create_app
    from app.cell_storage.models import CryoVial, VialBatch, CellLine, Box, Drawer, Tower
    from app.extensions import db
except ImportError as e:
    print(f"Error importing Flask app modules: {e}")
    print("Make sure you're running this from the project root directory.")
    sys.exit(1)

@dataclass
class ValidationError:
    """Represents a validation error for a specific row"""
    row_number: int
    row_data: List[str]
    error_message: str
    error_type: str
    severity: str = "ERROR"  # ERROR, WARNING, INFO

@dataclass
class ValidationResult:
    """Overall validation result"""
    is_valid: bool
    total_rows: int
    valid_rows: int
    errors: List[ValidationError]
    warnings: List[ValidationError]
    file_issues: List[str]
    summary: Dict[str, Any]

class CSVImportValidator:
    """Validates CSV files for import compatibility"""
    
    # Constants from the original import logic
    MAX_FILE_SIZE = 10 * 1024 * 1024  # 10MB
    MAX_ROWS = 10000
    
    # Expected headers
    EXPECTED_HEADERS_ADMIN = [
        'Vial ID', 'Batch ID', 'Batch Name', 'Vial Tag', 'Cell Line',
        'Passage Number', 'Date Frozen', 'Frozen By', 'Status', 'Location',
        'Volume (ml)', 'Concentration', 'Fluorescence Tag', 
        'Resistance', 'Parental Cell Line', 'Notes'
    ]
    
    EXPECTED_HEADERS_USER = [
        'Vial ID', 'Batch ID', 'Batch Name', 'Vial Tag', 'Cell Line',
        'Passage Number', 'Date Frozen', 'Frozen By', 'Status',
        'Volume (ml)', 'Concentration', 'Fluorescence Tag', 
        'Resistance', 'Parental Cell Line', 'Notes'
    ]
    
    VALID_STATUSES = ['Available', 'Used', 'Depleted', 'Discarded']
    
    def __init__(self):
        """Initialize validator with database connection"""
        self.app = create_app()
        self.errors = []
        self.warnings = []
        self.file_issues = []
        
    def validate_file(self, file_path: str) -> ValidationResult:
        """Main validation function"""
        file_path = Path(file_path)
        
        # Reset state
        self.errors = []
        self.warnings = []
        self.file_issues = []
        
        # Basic file checks
        if not self._validate_file_basic(file_path):
            return ValidationResult(
                is_valid=False,
                total_rows=0,
                valid_rows=0,
                errors=self.errors,
                warnings=self.warnings,
                file_issues=self.file_issues,
                summary={}
            )
        
        # Read and validate CSV content
        with self.app.app_context():
            return self._validate_csv_content(file_path)
    
    def _validate_file_basic(self, file_path: Path) -> bool:
        """Validate basic file properties"""
        # Check if file exists
        if not file_path.exists():
            self.file_issues.append(f"File does not exist: {file_path}")
            return False
        
        # Check file size
        file_size = file_path.stat().st_size
        if file_size > self.MAX_FILE_SIZE:
            self.file_issues.append(
                f"File size ({file_size // (1024*1024)}MB) exceeds maximum allowed size (10MB)"
            )
            return False
        
        if file_size == 0:
            self.file_issues.append("File is empty")
            return False
        
        # Check file extension
        if file_path.suffix.lower() != '.csv':
            self.warnings.append(ValidationError(
                row_number=0,
                row_data=[],
                error_message=f"File extension '{file_path.suffix}' is not '.csv'",
                error_type="FILE_EXTENSION",
                severity="WARNING"
            ))
        
        return True
    
    def _validate_csv_content(self, file_path: Path) -> ValidationResult:
        """Validate CSV content and structure"""
        try:
            # Read file with encoding detection
            content = self._read_file_with_encoding(file_path)
            if content is None:
                return self._create_failed_result(0)
            
            # Parse CSV
            stream = io.StringIO(content, newline=None)
            try:
                csv_reader = csv.reader(stream)
                header = next(csv_reader)
            except StopIteration:
                self.file_issues.append("CSV file appears to be empty or has no header row")
                return self._create_failed_result(0)
            except csv.Error as e:
                self.file_issues.append(f"Error parsing CSV file: {e}")
                return self._create_failed_result(0)
            
            # Validate header
            if not self._validate_header(header):
                return self._create_failed_result(0)
            
            has_location = 'Location' in header
            
            # Validate rows
            valid_rows = 0
            total_rows = 0
            existing_vial_tags = set()
            
            # Get existing vial tags from database
            existing_vials = {v.unique_vial_id_tag: v.id for v in CryoVial.query.all()}
            existing_cell_lines = {cl.name: cl.id for cl in CellLine.query.all()}
            existing_batches = {b.name: b.id for b in VialBatch.query.all()}
            
            for row_num, row in enumerate(csv_reader, 2):  # Start from line 2
                total_rows += 1
                
                # Check row limit
                if total_rows > self.MAX_ROWS:
                    self.file_issues.append(
                        f"File contains too many rows (maximum {self.MAX_ROWS:,} allowed). "
                        "Please split into smaller files."
                    )
                    break
                
                # Skip empty rows
                if not any(field.strip() for field in row):
                    continue
                
                # Validate this row
                if self._validate_row(
                    row_num, row, header, has_location, 
                    existing_vials, existing_cell_lines, existing_batches,
                    existing_vial_tags
                ):
                    valid_rows += 1
                    # Track new vial tags to detect duplicates within the file
                    row_data = dict(zip(header, row))
                    vial_tag = row_data.get('Vial Tag', '').strip()
                    if vial_tag:
                        existing_vial_tags.add(vial_tag)
            
            # Create result
            is_valid = len(self.errors) == 0 and len(self.file_issues) == 0
            
            summary = {
                'total_data_rows': total_rows,
                'valid_rows': valid_rows,
                'invalid_rows': len(self.errors),
                'warnings': len(self.warnings),
                'has_location_column': has_location,
                'header_type': 'admin' if has_location else 'user'
            }
            
            return ValidationResult(
                is_valid=is_valid,
                total_rows=total_rows,
                valid_rows=valid_rows,
                errors=self.errors,
                warnings=self.warnings,
                file_issues=self.file_issues,
                summary=summary
            )
            
        except Exception as e:
            self.file_issues.append(f"Unexpected error during validation: {str(e)}")
            return self._create_failed_result(0)
    
    def _read_file_with_encoding(self, file_path: Path) -> str:
        """Read file with encoding detection (mimics the import logic)"""
        try:
            with open(file_path, 'rb') as f:
                raw_data = f.read()
            
            # Try UTF-8 first
            try:
                return raw_data.decode('utf-8')
            except UnicodeDecodeError:
                # Try latin-1
                try:
                    return raw_data.decode('latin-1')
                except UnicodeDecodeError:
                    # Fallback with error replacement
                    self.warnings.append(ValidationError(
                        row_number=0,
                        row_data=[],
                        error_message="Some characters could not be decoded properly",
                        error_type="ENCODING",
                        severity="WARNING"
                    ))
                    return raw_data.decode('utf-8', errors='replace')
        except Exception as e:
            self.file_issues.append(f"Error reading file: {e}")
            return None
    
    def _validate_header(self, header: List[str]) -> bool:
        """Validate CSV header matches expected format"""
        if header == self.EXPECTED_HEADERS_ADMIN:
            return True
        elif header == self.EXPECTED_HEADERS_USER:
            return True
        else:
            self.file_issues.append(
                "CSV header does not match expected format. "
                "Please use an unmodified export file from Inventory Summary."
            )
            self.file_issues.append(f"Found header: {header}")
            self.file_issues.append(f"Expected (Admin): {self.EXPECTED_HEADERS_ADMIN}")
            self.file_issues.append(f"Expected (User): {self.EXPECTED_HEADERS_USER}")
            return False
    
    def _validate_row(self, row_num: int, row: List[str], header: List[str], 
                      has_location: bool, existing_vials: Dict[str, int],
                      existing_cell_lines: Dict[str, int], existing_batches: Dict[str, int],
                      existing_vial_tags: set) -> bool:
        """Validate a single data row"""
        is_valid = True
        
        # Check column count
        if len(row) != len(header):
            self._add_error(row_num, row, 
                f"Row has {len(row)} columns, expected {len(header)} columns",
                "COLUMN_COUNT")
            return False
        
        row_data = dict(zip(header, row))
        
        # Extract key fields
        vial_id = row_data.get('Vial ID', '').strip()
        vial_tag = row_data.get('Vial Tag', '').strip()
        batch_name = row_data.get('Batch Name', '').strip()
        cell_line_name = row_data.get('Cell Line', '').strip()
        
        # Determine if this is a new record or existing record
        is_new_record = self._determine_record_type(vial_id, vial_tag, existing_vials)
        
        # Validate based on record type
        if is_new_record:
            is_valid &= self._validate_new_record(
                row_num, row, row_data, vial_tag, batch_name, cell_line_name,
                has_location, existing_cell_lines, existing_vial_tags
            )
        else:
            is_valid &= self._validate_existing_record(
                row_num, row, row_data, vial_id, vial_tag, existing_vials
            )
        
        # Common validations
        is_valid &= self._validate_date_frozen(row_num, row, row_data)
        is_valid &= self._validate_location(row_num, row, row_data, has_location, is_new_record)
        is_valid &= self._validate_volume(row_num, row, row_data)
        is_valid &= self._validate_status(row_num, row, row_data)
        
        return is_valid
    
    def _determine_record_type(self, vial_id: str, vial_tag: str, existing_vials: Dict[str, int]) -> bool:
        """Determine if this is a new record or update to existing record"""
        if vial_id:
            try:
                vial_id_int = int(vial_id)
                # Check if vial ID exists in database
                existing_vial = CryoVial.query.get(vial_id_int)
                if existing_vial:
                    return False  # Existing record
                else:
                    return True   # New record (ID not found)
            except (ValueError, TypeError):
                return True  # Invalid ID format, treat as new
        else:
            return True  # No ID provided, definitely new
    
    def _validate_new_record(self, row_num: int, row: List[str], row_data: Dict[str, str],
                           vial_tag: str, batch_name: str, cell_line_name: str,
                           has_location: bool, existing_cell_lines: Dict[str, int],
                           existing_vial_tags: set) -> bool:
        """Validate a new record"""
        is_valid = True
        
        # Required fields for new records
        if not all([batch_name, cell_line_name, vial_tag]):
            self._add_error(row_num, row,
                "New records require Batch Name, Cell Line, and Vial Tag",
                "MISSING_REQUIRED_FIELDS")
            is_valid = False
        
        # Check if vial tag already exists
        if vial_tag and vial_tag in existing_vial_tags:
            self._add_error(row_num, row,
                f"Vial Tag '{vial_tag}' already exists or is duplicated in this file",
                "DUPLICATE_VIAL_TAG")
            is_valid = False
        
        # Check if cell line exists
        if cell_line_name and cell_line_name not in existing_cell_lines:
            self._add_error(row_num, row,
                f"Cell Line '{cell_line_name}' not found. Please create it first",
                "CELL_LINE_NOT_FOUND")
            is_valid = False
        
        # For new records, location is required if has_location
        if has_location:
            location_str = row_data.get('Location', '').strip()
            if not location_str:
                self._add_error(row_num, row,
                    "New records require a valid Location",
                    "MISSING_LOCATION")
                is_valid = False
        
        return is_valid
    
    def _validate_existing_record(self, row_num: int, row: List[str], row_data: Dict[str, str],
                                vial_id: str, vial_tag: str, existing_vials: Dict[str, int]) -> bool:
        """Validate an existing record update"""
        is_valid = True
        
        try:
            vial_id_int = int(vial_id)
            existing_vial = CryoVial.query.get(vial_id_int)
            
            if existing_vial and vial_tag:
                # Sanity check vial tag matches database
                if existing_vial.unique_vial_id_tag != vial_tag:
                    self._add_error(row_num, row,
                        "Vial Tag in file does not match database record",
                        "VIAL_TAG_MISMATCH")
                    is_valid = False
        except (ValueError, TypeError):
            # This shouldn't happen as we already checked in _determine_record_type
            pass
        
        return is_valid
    
    def _validate_date_frozen(self, row_num: int, row: List[str], row_data: Dict[str, str]) -> bool:
        """Validate date frozen format"""
        date_frozen_str = row_data.get('Date Frozen', '').strip()
        if date_frozen_str:
            try:
                datetime.strptime(date_frozen_str, '%Y-%m-%d')
            except ValueError:
                self._add_error(row_num, row,
                    "Invalid Date Frozen format (must be YYYY-MM-DD)",
                    "INVALID_DATE_FORMAT")
                return False
        return True
    
    def _validate_location(self, row_num: int, row: List[str], row_data: Dict[str, str],
                          has_location: bool, is_new_record: bool) -> bool:
        """Validate location format and existence"""
        if not has_location:
            return True
        
        location_str = row_data.get('Location', '').strip()
        if not location_str:
            return True  # Empty location is okay for updates
        
        # Parse location string: "Tower 1/Drawer 1/Box 1 R1C2"
        location_match = re.match(r'(.+)/(.+)/(.+)\s+R(\d+)C(\d+)', location_str)
        if not location_match:
            self._add_error(row_num, row,
                "Invalid Location format. Expected: 'Tower Name/Drawer Name/Box Name R#C#'",
                "INVALID_LOCATION_FORMAT")
            return False
        
        tower_name, drawer_name, box_name, row_str, col_str = location_match.groups()
        tower_name = tower_name.strip()
        drawer_name = drawer_name.strip()
        box_name = box_name.strip()
        
        # Check if location exists in database
        box = Box.query.join(Drawer).join(Tower).filter(
            Tower.name == tower_name,
            Drawer.name == drawer_name,
            Box.name == box_name
        ).first()
        
        if not box:
            self._add_error(row_num, row,
                f"Location '{location_str}' not found. Looking for Tower: '{tower_name}', "
                f"Drawer: '{drawer_name}', Box: '{box_name}'",
                "LOCATION_NOT_FOUND")
            return False
            
        # Validate row and column numbers
        try:
            row_num_box = int(row_str)
            col_num_box = int(col_str)
            if row_num_box < 1 or col_num_box < 1:
                self._add_error(row_num, row,
                    "Row and column numbers must be positive integers",
                    "INVALID_POSITION_NUMBERS")
                return False
        except ValueError:
            self._add_error(row_num, row,
                "Invalid row or column number in location",
                "INVALID_POSITION_FORMAT")
            return False
        
        return True
    
    def _validate_volume(self, row_num: int, row: List[str], row_data: Dict[str, str]) -> bool:
        """Validate volume field"""
        volume_str = row_data.get('Volume (ml)', '').strip()
        if volume_str:
            try:
                volume = float(volume_str)
                if volume < 0:
                    self._add_warning(row_num, row,
                        "Volume cannot be negative",
                        "NEGATIVE_VOLUME")
            except ValueError:
                self._add_error(row_num, row,
                    "Invalid volume format (must be a number)",
                    "INVALID_VOLUME_FORMAT")
                return False
        return True
    
    def _validate_status(self, row_num: int, row: List[str], row_data: Dict[str, str]) -> bool:
        """Validate status field"""
        status = row_data.get('Status', '').strip()
        if status and status not in self.VALID_STATUSES:
            self._add_warning(row_num, row,
                f"Status '{status}' is not one of the standard values: {', '.join(self.VALID_STATUSES)}",
                "INVALID_STATUS")
        return True
    
    def _add_error(self, row_num: int, row: List[str], message: str, error_type: str):
        """Add a validation error"""
        self.errors.append(ValidationError(
            row_number=row_num,
            row_data=row,
            error_message=message,
            error_type=error_type,
            severity="ERROR"
        ))
    
    def _add_warning(self, row_num: int, row: List[str], message: str, error_type: str):
        """Add a validation warning"""
        self.warnings.append(ValidationError(
            row_number=row_num,
            row_data=row,
            error_message=message,
            error_type=error_type,
            severity="WARNING"
        ))
    
    def _create_failed_result(self, total_rows: int) -> ValidationResult:
        """Create a failed validation result"""
        return ValidationResult(
            is_valid=False,
            total_rows=total_rows,
            valid_rows=0,
            errors=self.errors,
            warnings=self.warnings,
            file_issues=self.file_issues,
            summary={}
        )

def print_validation_report(result: ValidationResult, file_path: str):
    """Print a comprehensive validation report"""
    print("=" * 80)
    print(f"CSV Import Validation Report")
    print(f"File: {file_path}")
    print("=" * 80)
    
    # Overall status
    status = "‚úÖ VALID" if result.is_valid else "‚ùå INVALID"
    print(f"\nOverall Status: {status}")
    
    # File issues
    if result.file_issues:
        print(f"\nüö® File Issues ({len(result.file_issues)}):")
        for issue in result.file_issues:
            print(f"   ‚Ä¢ {issue}")
    
    # Summary statistics
    if result.summary:
        print(f"\nüìä Summary:")
        print(f"   ‚Ä¢ Total data rows: {result.summary.get('total_data_rows', 0):,}")
        print(f"   ‚Ä¢ Valid rows: {result.summary.get('valid_rows', 0):,}")
        print(f"   ‚Ä¢ Invalid rows: {result.summary.get('invalid_rows', 0):,}")
        print(f"   ‚Ä¢ Warnings: {result.summary.get('warnings', 0):,}")
        print(f"   ‚Ä¢ Header type: {result.summary.get('header_type', 'unknown')}")
        print(f"   ‚Ä¢ Has location column: {result.summary.get('has_location_column', False)}")
    
    # Errors
    if result.errors:
        print(f"\n‚ùå Errors ({len(result.errors)}):")
        error_counts = {}
        for error in result.errors:
            error_counts[error.error_type] = error_counts.get(error.error_type, 0) + 1
        
        for error_type, count in error_counts.items():
            print(f"   ‚Ä¢ {error_type}: {count} rows")
        
        print(f"\nDetailed Error List:")
        for error in result.errors[:50]:  # Limit to first 50 errors
            print(f"   Row {error.row_number}: {error.error_message}")
            if len(error.row_data) > 0:
                preview = ', '.join(error.row_data[:3]) + ('...' if len(error.row_data) > 3 else '')
                print(f"      Data: {preview}")
        
        if len(result.errors) > 50:
            print(f"   ... and {len(result.errors) - 50} more errors")
    
    # Warnings
    if result.warnings:
        print(f"\n‚ö†Ô∏è  Warnings ({len(result.warnings)}):")
        warning_counts = {}
        for warning in result.warnings:
            warning_counts[warning.error_type] = warning_counts.get(warning.error_type, 0) + 1
        
        for warning_type, count in warning_counts.items():
            print(f"   ‚Ä¢ {warning_type}: {count} rows")
        
        if len(result.warnings) <= 20:  # Show detailed warnings only if not too many
            print(f"\nDetailed Warning List:")
            for warning in result.warnings:
                print(f"   Row {warning.row_number}: {warning.error_message}")
    
    # Recommendation
    print(f"\nüí° Recommendation:")
    if result.is_valid:
        print("   The CSV file should import successfully!")
    else:
        print("   Fix the errors above before attempting to import.")
        if result.warnings:
            print("   Review warnings to ensure data quality.")
    
    print("=" * 80)

def main():
    """Main function"""
    if len(sys.argv) != 2:
        print("Usage: python csv_import_validator.py <csv_file_path>")
        print("\nExample:")
        print("  python csv_import_validator.py inventory_summary.csv")
        sys.exit(1)
    
    csv_file_path = sys.argv[1]
    
    # Validate the CSV file
    validator = CSVImportValidator()
    result = validator.validate_file(csv_file_path)
    
    # Print the report
    print_validation_report(result, csv_file_path)
    
    # Exit with appropriate code
    sys.exit(0 if result.is_valid else 1)

if __name__ == "__main__":
    main()